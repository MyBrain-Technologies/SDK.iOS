//
//  MBT_ComputeCalibration.cpp
//
//  Created by Fanny Grosselin on 04/01/17.
//  Inspired by MBT_ComputeCalibration.cpp of Emma Barme on 20/10/2015.
//  Copyright (c) 2017 myBrain Technologies. All rights reserved.
//

#include "../Headers/MBT_ComputeCalibration.h"

std::map<std::string, std::vector<float> > MBT_ComputeCalibration(MBT_Matrix<float> calibrationRecordings, MBT_Matrix<float> calibrationRecordingsQuality, const float sampRate, const int packetLength, const float IAFinf, const float IAFsup)
{
    std::map<std::string, std::vector<float> > calibrationParameters;

    //Selecting the packets with a good enough quality value.
    float qualityThreshold = 0.5; //The minimum quality value for a packet to be taken into account. Hard coded to 0.5.
    int channelNb = calibrationRecordings.size().first;
    std::vector<std::vector<int> > packetsToKeepIndex; //A two-dimensional vector holding for each channel (row) the indices of the good packets.
    packetsToKeepIndex.resize(channelNb);
    std::vector<float> meanQualities;
    meanQualities.assign(channelNb, 0);
    //For each channel
    for (int channelIndex = 0; channelIndex < channelNb; channelIndex++)
    {
        //For each packet
        for (int packetIndex = 0; packetIndex < calibrationRecordingsQuality.size().second; packetIndex++)
        {
            float quality = calibrationRecordingsQuality(channelIndex, packetIndex);
            //If the signal is good enough
            if (quality >= qualityThreshold)
            {
                meanQualities[channelIndex] += quality;
                packetsToKeepIndex[channelIndex].push_back(packetIndex);
            }
        }
        meanQualities[channelIndex] /= packetsToKeepIndex[channelIndex].size();
    }

    //Selecting the channel with the highest quality value.
    //TODO: Make it possible to use several channels at the same time.
    int bestChannelIndex = -1;
    float bestMeanQuality = -1;
    for (int channelIndex = 0; channelIndex < channelNb; channelIndex++)
    {
        if (bestMeanQuality < meanQualities[channelIndex]) // by this way if quality are equal in both channel, we keep the first one that is to say the left channel
        {
            bestMeanQuality = meanQualities[channelIndex];
            bestChannelIndex = channelIndex;
        }
    }
    //If the best channel has a quality lower than 0.5, fail.
    // Return value to be handled in case of problem / false and if needed to start calibration over and to use different values than default
    if (bestMeanQuality < qualityThreshold)
    {
        // Store values to be handled in case of problem into MBT_ComputeCalibration::computeCalibration
        std::vector<float> SNRCalib;
        SNRCalib.push_back(nan(" "));
        std::vector<float> bestChannel;
        bestChannel.push_back(nan(" "));
        calibrationParameters["BestChannel"] = bestChannel;
        calibrationParameters["SNRCalib_ofBestChannel"] = SNRCalib;
        errno = EINVAL;
        perror("ERROR: MBT_COMPUTECALIBRATION CANNOT PROCESS WITH ONLY BAD QUALITY SIGNALS");

        return calibrationParameters;
    }

    std::vector<float> SNRCalib;
    //Creating a new matrix with only the data values for the packets with a good quality value of the channel with the best mean quality value.
    MBT_Matrix<float> goodCalibrationRecordings(1, (int)packetsToKeepIndex[bestChannelIndex].size() * packetLength);
    for (int packetIndex = 0; packetIndex < packetsToKeepIndex[bestChannelIndex].size(); packetIndex++)
    {
        for (int dataPointInPacketIndex = 0; dataPointInPacketIndex < packetLength; dataPointInPacketIndex++)
        {
            goodCalibrationRecordings(0, dataPointInPacketIndex) = calibrationRecordings(bestChannelIndex, dataPointInPacketIndex + packetIndex * packetLength);
        }
        std::vector<float> SNRCalibPacket = MBT_ComputeSNR(goodCalibrationRecordings, sampRate, IAFinf, IAFsup,packetIndex,bestChannelIndex); // there is only one value into the vector SNRCalib because packetOfGoodCalibrationRecordings contains one packet of values of only the best channel.
        SNRCalib.push_back(SNRCalibPacket[0]);
    }

    std::vector<float> bestChannel;
    bestChannel.push_back(bestChannelIndex);

    // Store the parameters into calibrationParameters
    calibrationParameters["BestChannel"] = bestChannel;
    calibrationParameters["SNRCalib_ofBestChannel"] = SNRCalib;

    return calibrationParameters;
}
