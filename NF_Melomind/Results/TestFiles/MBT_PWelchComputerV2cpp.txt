//
//  MBT_PWelchComputer.cpp
//  MBT.iOS
//
//  Created by Emma Barme on 19/10/2015.
//  Copyright (c) 2015 Emma Barme. All rights reserved.
//
//  Update: Fanny Grosselin 2016/08/26
//          Fanny Grosselin 2016/12/13 --> add a method trendCorrection
//			Fanny Grosselin 2017/01/10 --> correct computeWindow

#include "../Headers/MBT_PWelchComputer.h"

void MBT_PWelchComputer::computePSD()
{
    const int signalLength = m_inputData.size().second;

    // ~~~ I. compute FFT on overlapped/windowed data ~~~

    // Get windowing size
    const int windowNumber = m_nbrWindows;
    const float tempWindowLength = signalLength / (windowNumber * (1 - m_overlap) + m_overlap);
    const int windowLength = floor(tempWindowLength);


    std::vector<MBT_Matrix<float> > segmentedSignal;
    segmentedSignal.assign(m_nbChannel, MBT_Matrix<float>(windowNumber, windowLength));

    // Padding to maximum between 256 and power of two
    int tmp_powerOfTwoLength = pow(2, floor(log(2 * windowLength - 1)/log(2))); // Fanny Grosselin 2017/01/17
    int powerOfTwoLength = std::max(256,tmp_powerOfTwoLength); // Fanny Grosselin 2017/01/17

    std::vector<MBT_Matrix<std::complex<float> > > complexSignal;
    //complexSignal.assign(m_nbChannel, MBT_Matrix<std::complex<float> >(windowNumber, windowLength));
    complexSignal.assign(m_nbChannel, MBT_Matrix<std::complex<float> >(windowNumber, powerOfTwoLength)); // Fanny Grosselin 2017/01/17

    std::vector<float> WindowSignal; // Fanny Grosselin 2017/01/17
    WindowSignal.assign(windowLength,0); // Fanny Grosselin 2017/01/17
    // Fanny Grosselin 2017/01/17
    float U = 0;
    for (int i = 0; i < windowLength; i++)
    {
        WindowSignal[i] = computeWindow(windowLength, i);
        U = U + WindowSignal[i]*WindowSignal[i]; // compute the power of the window
    }
    std::cout<<"U = "<<U<<std::endl;
    std::cout<<"signalLength = "<<signalLength<<std::endl;
    std::cout<<"m_overlap = "<<m_overlap<<std::endl;
    std::cout<<"windowNumber = "<<windowNumber<<std::endl;
    std::cout<<"tempWindowLength = "<<tempWindowLength<<std::endl;
    std::cout<<"windowLength = "<<windowLength<<std::endl;
    std::cout<<"powerOfTwoLength = "<<powerOfTwoLength<<std::endl;

    //Cut the input data into m_nbrWindow segments
    for (int channel = 0; channel < m_nbChannel; channel++)
    {
        for (int window = 0; window < windowNumber; window++)
        {
            const int starting_index = floor(window * windowLength * (1.0 - m_overlap));

            for (int i = 0; i < windowLength; i++)
            {
                segmentedSignal[channel](window, i) = m_inputData(channel, starting_index + i);
                //complexSignal[channel](window, i) = segmentedSignal[channel](window, i) * computeWindow(windowLength, window);
                complexSignal[channel](window, i) = segmentedSignal[channel](window, i) * computeWindow(windowLength, i); // Fanny Grosselin 2017/01/12 because "n" of computeWindow should be in [0:windowLength-1];
            }

            // Fanny Grosselin 2017/01/17
            for (int i = powerOfTwoLength - windowLength + 1; i < powerOfTwoLength; i++)
            {
                complexSignal[channel](window, i) = 0;
            }
        }
    }

    // compute FFT in place
    for (int window = 0; window < windowNumber; window++)
    {
        for (int channel = 0; channel < m_nbChannel; channel++)
        {
            std::vector<std::complex<float> > dataToTransform = complexSignal[channel].row(window);

            //MBT_Fourier::forwardBluesteinFFT(dataToTransform);
            fft(-1, dataToTransform);

            for (int i = 0; i < dataToTransform.size(); i++)
            {
                complexSignal[channel](window, i) = dataToTransform[i];
            }
            //std::cout<<"dataToTransform.size() = "<<dataToTransform.size()<<std::endl;
        }
    }

    // ~~~ II. compute PSD ~~~
    //m_psd = MBT_Matrix<float>(m_nbChannel + 1, windowLength); //Freq, Pchannel1, Pchannel2...
    m_psd = MBT_Matrix<float>(m_nbChannel + 1, powerOfTwoLength); //Freq, Pchannel1, Pchannel2... // Fanny Grosselin 2017/01/17

    //for (int i = 0; i < windowLength; i++)
    for (int i = 0; i < powerOfTwoLength; i++) // Fanny Grosselin 2017/01/17
    {
        //m_psd(0, i) = (float)(i) * (m_sampRate / windowLength);
        m_psd(0, i) = (float)(i) * (m_sampRate / powerOfTwoLength); // Fanny Grosselin 2017/01/17


        for (int channel = 1; channel <= m_nbChannel; channel++)
        {
            m_psd(channel, i) = 0;

            for (int window = 0; window < windowNumber; window++)
            {
                //m_psd(channel, i) += pow(std::abs(complexSignal[channel - 1](window, i)), 2.0);
                m_psd(channel, i) += (pow(std::abs(complexSignal[channel - 1](window, i)), 2.0))/U; // Fanny Grosselin 2017/01/17 // Compensate for the power of the window
            }

            // Average the sum of the periodograms
            //m_psd(channel, i) = 10 * log10(m_psd(channel, i) / windowNumber);
            m_psd(channel, i) = (m_psd(channel, i) / windowNumber);// Fanny Grosselin 2016/08/26
        }
    }


    // Fanny Grosselin 2017/01/17
    // Generate the one-sided spectrum
    if (fmod(powerOfTwoLength,2) == 1) // if odd (impair)
    {
        m_psd_Scaled = MBT_Matrix<float>(m_nbChannel + 1, (powerOfTwoLength+1)/2); //Freq, Pchannel1, Pchannel2...

        for (int i=0; i<(powerOfTwoLength+1)/2; i++)
        {
            m_psd_Scaled(0,i) = m_psd(0,i);
            for (int channel = 1; channel <= m_nbChannel; channel++)
            {
                if (i!=0)
                {
                    //m_psd_Scaled(channel,i) = 2*m_psd(channel, i);
                    m_psd_Scaled(channel,i) = 2*m_psd(channel, i)/m_sampRate;
                }
                else // only DC is a unique point and doesn't get doubled
                {
                    //m_psd_Scaled(channel,i) = m_psd(channel, i);
                    m_psd_Scaled(channel,i) = m_psd(channel, i)/m_sampRate;
                }
            }
        }
    }
    else // if even (pair)
    {
        m_psd_Scaled = MBT_Matrix<float>(m_nbChannel + 1, powerOfTwoLength/2 +1); //Freq, Pchannel1, Pchannel2...

        for (int i=0; i<powerOfTwoLength/2+1; i++)
        {
            m_psd_Scaled(0,i) = m_psd(0,i);
            for (int channel = 1; channel <= m_nbChannel; channel++)
            {
                if (i!=0 & i!=powerOfTwoLength/2)
                {
                    //m_psd_Scaled(channel,i) = 2*m_psd(channel, i);
                    m_psd_Scaled(channel,i) = 2*m_psd(channel, i)/m_sampRate;
                }
                else // don't double unique Nyquist point
                {
                    //m_psd_Scaled(channel,i) = m_psd(channel, i);
                    m_psd_Scaled(channel,i) = m_psd(channel, i)/m_sampRate;
                }
            }
        }
    }

}


float MBT_PWelchComputer::computeWindow(int windowLength, int n) const
{
    const float  PI_F=3.14159265358979f;
    switch (m_windowType) {
        case RECT:
            return 1;
            break;

        case HANN:
			//return (1.0 - cos(2.0 * PI_F * n / windowLength)) / 2.0;
            return (1.0 - cos(2.0 * PI_F * n / (windowLength-1))) / 2.0; // Fanny Grosselin 2017/01/10 (windowLength-1) instead of windowLength
            break;

        case HAMMING:
			//return 0.54 - 0.46 * cos(2.0 * PI_F * n / windowLength);
            return 0.54 - 0.46 * cos(2.0 * PI_F * n / (windowLength-1));  // Fanny Grosselin 2017/01/10 (windowLength-1) instead of windowLength
            break;

        default:
            break;
    }
}



MBT_PWelchComputer::MBT_PWelchComputer(MBT_Matrix<float> const& inputData, const float sampRate, std::string windowType)
{
    //Initialize input parameters.
    m_sampRate = sampRate;
    if (windowType == "RECT")
    {
        m_windowType = RECT;
    }
    else if (windowType == "HANN")
    {
        m_windowType = HANN;
    }
    else if (windowType == "HAMMING")
    {
        m_windowType = HAMMING;
    }
    else
    {
        std::cerr << "WARNING: UNKNOWN WINDOW TYPE, USING DEFAULT" << std::endl;
    }
    m_inputData = inputData;
    m_nbChannel = m_inputData.size().first;

    //Compute the PSD
    computePSD();
}


MBT_PWelchComputer::~MBT_PWelchComputer()
{

}


MBT_Matrix<float> MBT_PWelchComputer::get_PSD() const
{
    //return m_psd;
    return m_psd_Scaled; // Fanny Grosselin 2017/01/17
}


std::vector<float> MBT_PWelchComputer::get_PSD(int channelIndex) const
{
    //return m_psd.row(channelIndex);
    return m_psd_Scaled.row(channelIndex); // Fanny Grosselin 2017/01/17
}


// Fanny Grosselin 2016/12/13
MBT_Matrix<float> MBT_trendCorrection(MBT_Matrix<float> inputData, const float sampRate)
{
    MBT_Matrix<float> correctedSignal;
    correctedSignal = MBT_Matrix<float>(inputData.size().first, inputData.size().second-1);

    for (int channel = 0; channel < inputData.size().first; channel++)
    {
        for (int i = 1; i < inputData.size().second; i++)
        {
            correctedSignal(channel, i-1) = (inputData(channel,i)-inputData(channel,i-1))/(1/sampRate);
        }
    }
    return correctedSignal;
}


void fft(int sign, std::vector<std::complex<float>> &zs)
{
    const float  PI_F=3.14159265358979f;
    unsigned int j=0;
    // Warning about signed vs unsigned comparison
    for(unsigned int i=0; i<zs.size()-1; ++i)
    {
        if (i < j) {
            auto t = zs.at(i);
            zs.at(i) = zs.at(j);
            zs.at(j) = t;
        }
        int m=zs.size()/2;
        j^=m;
        while ((j & m) == 0) { m/=2; j^=m; }
    }
    for(unsigned int j=1; j<zs.size(); j*=2)
        for(unsigned int m=0; m<j; ++m)
        {
            auto t = PI_F * sign * m / j;
            auto w = std::complex<float>(cos(t), sin(t));
            for(unsigned int i = m; i<zs.size(); i+=2*j)
            {
                std::complex<float> zi = zs.at(i), t = w * zs.at(i + j);
                zs.at(i) = zi + t;
                zs.at(i + j) = zi - t;
            }
        }
}
